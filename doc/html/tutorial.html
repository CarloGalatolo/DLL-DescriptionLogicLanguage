<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.8.20"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Tutorial</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="../css/styles.css" rel="stylesheet" />
</head>

<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
	 <tr>
		 <img src="../immagini/logo.png" style="margin-top: 3px; margin-left: 3px;" />
	 </tr>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDLL - Simple Description Logic Language
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial di SDLL</div>  </div>
</div><!--header-->
<div class="contents">
  <h1>Come usare SDLL</h1>
  <p>
	SDLL è un linguaggio dalla sintassi estremamente semplice ma dalle ampie potenzialità. Per mettere in moto l'interprete basta 
	realizzare un singolo file di testo con estensione "<normal class="code">.dl</normal>" contenente l'intero set di asserzioni 
	che definisce il dominio di interesse e l'interpretazione da applicare.<br/>
	Il linguaggio richiede che il file in questione sia diviso in tre sezioni, eventualmente vuote, separate da una 
	riga contenente esclusivamente "<normal class="code">%%</normal>" o spazi bianchi, senza altri caratteri (commenti inclusi).<br/>
	Per esempio, il più banale codice ammesso è un testo contenente solo due linee di sezione, come il seguente:<br/>
	<table class="interpreter">
		<tr>
			<th class="th_int">empty.dl</th>
		</tr>
		<tr>
			<td class="td_int">
				<pre>
%%
%%
</pre>
			</td>
		</tr>
	</table>
	Ciascuna di queste sezioni permette istruzioni di tipo diverso al suo interno, così da assicurare un flusso di esecuzione
	prestabilito e che previene ambiguità, oltre ad una maggiore affinità con la logica descrittiva stessa.<br/>
	Di seguito, sono elencate le tre sezioni dei codici di SDLL, insieme a una descrizione dettagliata. 
	Il linguaggio non è case sensitive, ma si consiglia di scrivere le parole chiave in maiuscolo per facilitare la leggibilità.
  </p>
  
  <h2>Names Declaration</h2>
  <p>
	In questa sezione vengono dichiarati i nomi dei concetti atomici, dei ruoli atomici e degli individui che fanno parte del dominio
	di applicazione. Per convenzione, i nomi dei concetti hanno l'iniziale maiuscola e le camel caps se sono composti, 
	i nomi dei ruoli hanno l'iniziale minuscola e le camel caps se sono composti e i nomi degli individui sono 
	scritti in minuscolo. <br/>
	Ciascun nome costituirà un'istanza di un oggetto del tipo indicato, ma non saranno inseriti individui né nei concetti né nei ruoli.<br/>
	<br/>Un'istruzione all'interno della sezione di dichiarazione dei nomi si scrive indicando per primo il tipo di oggetto 
	(<normal class="code">CONCEPT</normal>, <normal class="code">ROLE</normal> oppure <normal class="code">INDV</normal> 
	o <normal class="code">INDIVIDUAL</normal>), seguito dal nome da assegnare all'oggetto.
	Ogni istruzione deve terminare con un '<normal class="code">;</normal>', ed è possibile concatenare l'istanziazione di più 
	oggetti dello stesso tipo separandoli da una '<normal class="code">,</normal>'.<br/>
	Di seguito un codice di esempio che costruisce una base di conoscenze simile a quella dello schema di esempio:<br/>
	<table class="interpreter">
		<tr>
			<th class="th_int">names_declaration</th>
		</tr>
		<tr>
			<td class="td_int">
<pre>
CONCEPT Student, Employee, EmpStud, Parent, Company, Tax;
ROLE pays, worksFor, empBy;
INDV john, mary, ibm, tax1;
</pre>
			</td>
		</tr>
	</table>
  </p>
  
  <h2>ABox</h2>
  <p>
	Nella logica descrittiva, la ABox è la lista delle asserzioni che istanziano gli individui all'interno dei concetti o 
	dei ruoli. In SDLL, assume lo stesso ruolo.<br/>
	Le istruzioni all'interno della sezione ABox sono di due tipi: asserzione di un concetto e asserzione di un ruolo. 
	Un'asserzione di un concetto inserisce un individuo in un concetto, separando il primo dal secondo usando 
	'<normal class="code">:</normal>'. 
	Un'asserzione di un ruolo istanzia una coppia di individui nel ruolo indicato. La coppia di individui va inclusa tra 
	'<normal class="code">(</normal>' e '<normal class="code">)</normal>' e separata da una '<normal class="code">,</normal>'. 
	In entrambi i casi, ancora una volta, ogni istruzione va terminata con un '<normal class="code">;</normal>' ed è 
	possibile concatenare le istanziazioni di 	diversi individui nello stesso concetto o diverse coppie di individui nello 
	stesso ruolo separandole da una '<normal class="code">,</normal>'.<br/>
	Di seguito un codice di esempio:<br/>
	<table class="interpreter">
		<tr>
			<th class="th_int">abox</th>
		</tr>
		<tr>
			<td class="td_int">
				<pre>
mary : Parent;
john, mary : Employee;
john : Student;
ibm : Company;

(john, ibm), (mary, ibm) : worksFor;
(john, ibm) : empBy;
(mary, tax1) : pays;
</pre>
			</td>
		</tr>
	</table>
  </p>

  <h2>TBox</h2>
  <p>
	  La TBox è quell'insieme di statement della logica descrittiva che determinano le regole di consistenza della base di 
	  conoscenze. In SDLL sono queste regole che costruiscono di fatto la base, aggiornando i concetti atomici e 
	  creando i concetti complessi.<br/>
	  Un concetto complesso è il risultato di una funzione aggregata, e si realizza in modi diversi a seconda dell'operatore 
	  usato:<br/>
	  <ul>
		  <li>
			  Un costruttore booleano si utilizza esattamente come un qualsiasi operatore unario o binario della matematica 
			  (<normal class="concept">A</normal> e <normal class="concept">B</normal> sono concetti):<br/>
			  <ul class="code">
				  <li>A CONJ B</li>
				  <li>A DISJ B</li>
				  <li>!A</li>
			  </ul>
		  </li>
		  <li>
			  Una restrizione di ruolo, invece, ha una sintassi insolita, come le seguenti 
			  (<normal class="concept">C</normal> è un concetto, <normal class="role">r</normal> è un ruolo):
			  <ul class="code">
				  <li>EX r . C</li>
				  <li>ALL r . C</li>
			  </ul>
		  </li>
	  </ul>
	  Un'istruzione all'interno della sezione TBox solitamente consiste nella combinazione di più concetti atomici e non, in modi  
	  diversi e in ordine diverso, inserendoli all'interno di una regola di sussunzione, coincidenza o alias.<br/>
	  Ogni istruzione deve terminare con un '<normal class="code">;</normal>', ed è possibile concatenare operatori diversi solo 
	  mediante l'uso di parentesi.<br/>
	  In ogni caso, solo un'operazione di sussunzione, congiunzione o alias è consentita in una singola istruzione.<br/>
	  SDLL permette anche istruzioni che non comprendono una sussunzione, coincidenza o alias. Queste istruzioni sono 
	  assimilabili alle query delle basi di dati, permettendo di creare concetti complessi per recuperare particolari individui.<br/>
	  Nel codice di seguito, la sezione di codice che termina la base di conoscenze in esame:<br/>

	  <table class="interpreter">
		<tr>
			<th class="th_int">tbox</th>
		</tr>
		<tr>
			<td class="td_int">
<pre>
EmpStud SUBS Student;              // Sussunzione
Student CONJ Employee == EmpStud;  // Coincidenza
Employee DISJ Parent = Worker;     // Alias
EX worksFor . Company;             // "Query"
</pre>
			</td>
		</tr>
	</table>
  </p>

  <h2>L'esempio completo</h2>
  <p>
	  Con le tre sezioni di esempio mostrate prima si realizza un codice intero di SDLL, che dunque avrà la forma seguente:<br/>
	  <table class="interpreter">
		<tr>
			<th class="th_int">example.dl</th>
		</tr>
		<tr>
			<td class="td_int">
<pre>
// Names Declaration

CONCEPT Student, Employee, EmpStud, Parent, Company, Tax;
ROLE pays, worksFor, empBy;
INDV john, mary, ibm, tax1;

%%

// ABox

mary : Parent;
john, mary : Employee;
john : Student;
ibm : Company;

(john, ibm), (mary, ibm) : worksFor;
(john, ibm) : empBy;
(mary, tax1) : pays;

%%

// TBox

EmpStud SUBS Student;
Student CONJ Employee == EmpStud;
Employee DISJ Parent = Worker;
!(Tax DISJ Company) = Person;
</pre>
			</td>
		</tr>
	</table>
  </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
</small></address>
</body>
</html>
