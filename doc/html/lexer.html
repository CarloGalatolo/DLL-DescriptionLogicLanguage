<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDLL: Lexer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<style>
    table.interpreter {
      font-family: arial, sans-serif;
      border-collapse: collapse;
      width: 100%;
    }
    
    td.td_int, th.th_int {
      border: 1px solid #dddddd;
      text-align: left;
      padding: 8px;
    }

    pre{
      border: 1px solid #dddddd;
      text-align: left;
      padding: 8px;
    }
    
    tr:nth-child(odd) {
      background-color: #dddddd;
    }
</style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
	 <tr>
		 <img src="../immagini/logo.png" style="margin-top: 3px; margin-left: 3px;" />
	 </tr>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SDLL - Simple Description Logic Language
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"> <div class="title">Lexer</div> </div>
</div><!--header-->
<div class="contents">
<h1 style="color: #008d8d;">Codice lexer</h1>
 <p>
    Di seguito viene riportata nel dettaglio la scrittura del Lexer. Il parser è salvato nel file corrispondente alla directory /build/lexer.l
 </p>
 <table class="interpreter">
    <tr>
      <th class="th_int">lexer.l</th>
    </tr>
    <tr>
      <td class="td_int">
   <pre>
%{
    #include <string>

    /* Implementation of yyFlexScanner */
    #include "src/dl_scanner.hpp"
    #undef  YY_DECL
    #define YY_DECL int DL::DL_Scanner::yylex( DL::DL_Parser::semantic_type * const lval,   DL::DL_Parser::location_type *location )
    /* using "token" to make the returns for the tokens shorter to type */
    using token = DL::DL_Parser::token;
    #define yyterminate() return( token::END )
    #define YY_NO_UNISTD_H
    #define YY_USER_ACTION loc->step(); loc->columns(yyleng);
	
    int oldstate;
    int comment_start = 0;
%}
</pre>
            <p>
              Ridefinisce funzioni del Lexer per renderle compatibile con C++, inoltre la direttiva using per accorciare l’utilizzo del path dei token.
            </p>  
      </td>
    </tr>
  </table>
  <br \><br \><br \>
  <table class="interpreter">
    <tr>
      <th class="th_int">lexer.l</th>
    </tr>
    <tr>
      <td class="td_int">
   <pre>
^[ \t]*%%[ \t]*$                    { return token::SECTION; }
^[ \t]*.+[ \t]*%%[ \t]*$            { /* error action */ }
^[ \t]*%%[ \t]*.+[ \t]*$            { /* error action */ }
^[ \t]*.+[ \t]*%%[ \t]*.+[ \t]*$    { /* error action */ }

"."     { return token::DOT; }
":" |   
"," | 
";" |    
"!" |    
"=" |    
"(" |
")"     { return yytext[0]; }

"=="    { return token::COINCIDENCE; }
</pre>
        <p>
          Definisce i caratteri utilizzati per definire le varie operazioni, dalle sezioni del DL alla concatenazione di operazioni e la coincidenza.
        </p>   
      </td>
    </tr>
  </table>
  <br \><br \><br \>
  <table class="interpreter">
    <tr>
      <th class="th_int">lexer.l</th>
    </tr>
    <tr>
      <td class="td_int">
<pre>
ALL               { return token::ALL;     }
CONCEPT           { return token::CONCEPT; }
CONJ(UNCTION)?    { return token::CONJ;    }
DISJ(UNCTION)?    { return token::DISJ;    }
EX(ISTS)?         { return token::EX;      }
(INDIVIDUAL|INDV) { return token::INDV;    }
ROLE              { return token::ROLE;    }
SUBS(UMPTION)?    { return token::SUBS;    }
</pre>
        <p>
   			Le parole chiave del linguaggio dedicate alle funzioni aggregate.       
        </p>   
      </td>
    </tr>
  </table>
  <br \><br \><br \>
  <table class="interpreter">
    <tr>
      <th class="th_int">lexer.l</th>
    </tr>
    <tr>
      <td class="td_int">
   <pre>
[a-zA-Z_][a-zA-Z0-9_]* { yylval->build<std::string>(yytext); return token::NAME; }

"/*"             { comment_start = yylineno; oldstate = YY_START; BEGIN COMMENT;  }
&lt;COMMENT&gt;"*/"    { BEGIN oldstate; }
&lt;COMMENT&gt;.|\n    ;
&lt;COMMENT&gt;&lt;&lt;EOF&gt;&gt; { /* error action */ }

[ \t\n] |
"//".*  ;    // C++-style comment.
</pre>
        <p>
         Questa regola gestisce la lettura dei nomi, utilizzata per la definizione dei concetti all’interno del Bison, oltre che funzionalità aggiuntive simil-C per la scrittura di commenti all’interno del documento.      
        </p>   
      </td>
    </tr>
  </table>
  <br \><br \><br \>
</div>
<!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
</small></address>
</body>
</html>